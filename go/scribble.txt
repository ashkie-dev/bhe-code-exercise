/ func filterList(listOfPrimes []bool, topNumber int64) []int64 {
// }

// ============================================ //

// Sieve interface
// type SortStrategy interface {
// 	Sort([]int)
// }

// // Finder
// type Sorter struct {
// 	strategy SortStrategy
// }

// type QuickSort struct{}

// func (qs QuickSort) Sort(data []int) {
// 	// Implementation of quicksort
// 	fmt.Println("Sorting using quicksort")
// }

// type MergeSort struct{}

// // NthPrime
// func (ms MergeSort) Sort(data []int) {
// 	// Implementation of merge sort
// 	fmt.Println("Sorting using merge sort")
// }

// func (s *Sorter) SetStrategy(strategy SortStrategy) {
// 	s.strategy = strategy
// }

// func (s *Sorter) Sort(data []int) {
// 	s.strategy.Sort(data)
// }

// func main() {
// 	sorter := Sorter{}

// 	// Use quicksort
// 	sorter.SetStrategy(QuickSort{})
// 	sorter.Sort([]int{3, 1, 4, 1, 5})

// 	// Switch to merge sort
// 	sorter.SetStrategy(MergeSort{})
// 	sorter.Sort([]int{3, 1, 4, 1, 5})
// }

// รท===============================================รท
// func primeFinder(s Sieve, topNumber int64) {
// list of bools
// topNumber = s.NthPrime(topNumber)
//
// primesList := make([]bool, topNumber+1)
// sets all numbers to prime...i think
// for i := int64(2); i <= topNumber; i++ {
// primesList[i] = true
// }
//
// for number := int64(2); number*number <= topNumber; number++ {
// if primesList[number] {
// for multiple := number * 2; multiple <= topNumber; multiple += number {
// primesList[multiple] = false
// }
// }
//
// }
// filteredPrimesList := filterList(primesList, topNumber)
// fmt.Print(filteredPrimesList)
// }

// function to filter primesList and returns filtered list

// func main() {
// 	primeFinder()
// }

======================================


	// Collect all prime numbers into a result slice.
	var primes []int
	for i := 2; i <= n; i++ {
		if isPrime[i] {
			primes = append(primes, i)
		}
	}

	return primes

